/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"
#include "pila_char.h"
#include "pila_numeros.h"
#include <stdbool.h>
#include <ctype.h>


#define PARENTESIS_IZQ '('
#define PARENTESIS_DER ')'
#define OP_SUMA '+'
#define OP_RESTA '-'
#define OP_MULT '*'
#define OP_DIV '/'

#define PUNTO_DECIMAL '.'
#define SEPARADOR ' '



struct control_errores{
	int error;
	msg_error msg_error;
};


bool es_operador_correcto(char op)
{
   return op == OP_SUMA || op == OP_RESTA || op == OP_MULT || op == OP_DIV;
}


short precedencia(char operador)
{
   if (operador == PARENTESIS_IZQ)
      return 0; 
   else if (operador == OP_SUMA || operador == OP_RESTA)
      return 1;
   else if (operador == OP_MULT || operador == OP_DIV)
      return 2;
   else
      return -1;
}


struct control_errores infija_to_postfija(char * infija, char * posfija)
{
   const int TAM_PILA = 100;
   struct pila_char pila_operadores = crea_pila_char(TAM_PILA);
	struct control_errores result;
	result.error = 0;

   int ind_postfija = 0;
   bool antes_punto = true;
   bool error_sintaxis = false;


   for (int ind_infija=0; infija[ind_infija] != '\0' && !error_sintaxis; ++ind_infija)
   {
      if (isdigit(infija[ind_infija]))
      {
         posfija[ind_postfija] = infija[ind_infija];
         ++ind_postfija;
      }
      else if (infija[ind_infija] == PUNTO_DECIMAL)
      {
         if (antes_punto)
         {
            antes_punto = false;
            posfija[ind_postfija] = infija[ind_infija];
            ++ind_postfija;
         }
         else
         {
            error_sintaxis = true;
				result.error = 1;
				result.msg_error = "Error de sintaxis: aparece el . dos veces seguidas";
         }
      }
      else
      {
         antes_punto = true;
         posfija[ind_postfija] = SEPARADOR;
         ind_postfija++;

         if (infija[ind_infija] == PARENTESIS_IZQ)
         {
            push_pila_char(&pila_operadores, PARENTESIS_IZQ);
         }
         else if (infija[ind_infija] == PARENTESIS_DER)
         {
            while(top_pila_char(&pila_operadores) != PARENTESIS_IZQ)
            {
               posfija[ind_postfija] = pop_pila_char(&pila_operadores);
               ++ind_postfija;
            }
            pop_pila_char(&pila_operadores); // Eliminamos el paréntesis izq
         }
         else if (es_operador_correcto(infija[ind_infija]))
         {
            while(!esta_vacia_pila_char(&pila_operadores)
            && 
            precedencia(top_pila_char(&pila_operadores)) >= precedencia(infija[ind_infija]))
            {
               posfija[ind_postfija] = pop_pila_char(&pila_operadores);
               ++ind_postfija;
            }

            push_pila_char(&pila_operadores, infija[ind_infija]);
         }
			else{
				error_sintaxis = true;
				result.error = 1;
				result.msg_error = "Error de sintaxis: operador no válido";
			}
      }
   } // end for

   while (!esta_vacia_pila_char(&pila_operadores))
   {
      posfija[ind_postfija] = pop_pila_char(&pila_operadores);
      ++ind_postfija;
   }

   posfija[ind_postfija] = '\0';

   libera_pila_char(&pila_operadores);

	return result;
}



double calcula(double num1, double num2, char operacion)
{
   double resultado = 0.0;

   if (operacion == OP_SUMA)
      resultado = num1+num2;
   else if (operacion == OP_RESTA)
      resultado = num1 - num2;
   else if (operacion == OP_MULT)
      resultado = num1 * num2;
   else if (operacion == OP_DIV)
      resultado = num1 / num2;
   
   return resultado;
}


calc_res evalua_postfijo(char * postfijo)
{
   const short TAM = 10;
   struct pila_numeros pila_operandos = crea_pila_numeros(TAM);
   double num1, num2;
	calc_res resultado;

   for (int i=0; postfijo[i] != '\0'; ++i)
   {
      if (isdigit(postfijo[i]) || postfijo[i] == PUNTO_DECIMAL)
      {
         push_pila_numeros(&pila_operandos, atof(postfijo + i*sizeof(char)));
         
         while (isdigit(postfijo[i+1]) || postfijo[i+1] == PUNTO_DECIMAL)
         {
            ++i;
         }
      }
      else if (postfijo[i] != SEPARADOR)
      {
         num2 = pop_pila_numeros(&pila_operandos);
         num1 = pop_pila_numeros(&pila_operandos);

			if (num2 == 0.0 && postfijo[i] == OP_DIV){
				resultado.error = 1;
				resultado.calc_res_u.msg_error = "Error: división por 0 no permitida";
				return resultado;
			}

         resultado.calc_res_u.resultado = calcula(num1, num2, postfijo[i]);
         push_pila_numeros(&pila_operandos, resultado.calc_res_u.resultado);
      }
   }

   resultado.calc_res_u.resultado = pop_pila_numeros(&pila_operandos);
   libera_pila_numeros(&pila_operandos);

   return resultado;
}


calc_res * calcula_1_svc(expr_mat expr_infija,  struct svc_req *rqstp)
{
	static calc_res result;
	struct control_errores control;

	char expr_postfija[TAM_EXPR_MATEMATICA*2];
	control = infija_to_postfija(expr_infija, expr_postfija);

	if (!control.error)
		result = evalua_postfijo(expr_postfija);  
	else{
		result.error = 1;
		result.calc_res_u.msg_error = control.msg_error;
   }

	return &result;
}
